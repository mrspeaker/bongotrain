* Bongo x Bongo

Welcom to bongo.

** Bongo x Bongo
`bongo.lua` is a trainer for Bongo, including a new game mode: OGNOB MODE.
See the `RUNNING` section in the file for instructions (tl;dr:  `mame bongo --autoboot_script ./bongo.lua`)

** Reverse engineered disassembly
`bongo_src.asm` is an annotated version of the Bongo source code. I used AI to generate the symbols and subroutine names. Did I say AI? I meant I tediously poured over the listing, manually search-replacing symbols as I figured out what they were for. Not 100% complete, but I think all the good stuff has been uncovered.

** Building ROMs
The Bongo source can be compiled with the `zmac` z80 compiler, then split into chunks that recreate the original Bongo ROM files. The output is a set of MAME-exact ROMS (i.e.; they have the correct CRCs) 

`build.sh` that will chop the front off the `bongo_src.asm` (I need the bytes for reference, but can't compile with them). This generates `src.asm`, which is compiled by `zmac`. The output file is split into 4k chunks, and each chunk compared against the origin ROM dumps to make sure nothing has been broken.

Once `bongo_src.asm` is 100% symbol-ized, it will be deleted and `src.asm` will be the one-true-source of Bongo. 


** scratchpad

#+BEGIN_SRC elisp
  (defun rst38 (start end)
    (interactive (if (use-region-p)
                     (list (region-beginning) (region-end))
                   (list nil nil)))
    (let ((c (count-lines start end))
          (retp (string-equal
                 "C9"
                 (buffer-substring-no-properties (+ start 6) (+ start 8))))
          (addr (buffer-substring-no-properties start (+ start 4) )))
      (message (format "%s" retp))
      (replace-region-contents start end
                               (lambda ()
                                 (format "%s%s                dc   %d, $FF"
                                         (if (not retp) ""  "");not doing this
                                         addr c)))))

  (defun rst39 (start end)
    (interactive (if (use-region-p)
                     (list (region-beginning) (region-end))
                   (list nil nil)))
    (rst38 start end)
    (goto-char start)
    (insert "\n")
    )

  (defun replace-line (fun)
    (interactive)
    (let ((line (thing-at-point 'line t)))
      (end-of-line)
      (newline)
      (insert (funcall fun (substring line 0 -1)))
      (previous-line)
      (delete-line)
      (forward-line 1)
      )
    )

  (defun string-chunk (str n)
    (mapcar (lambda (p) (s-join "" p))
            (seq-partition (s-split "" str t) n)))

  (defun byteify()
    (interactive)
    (replace-line
     (lambda (line)
       (let ((addr (substring-no-properties line 0 4))
             (bytes (s-trim (substring-no-properties line 6 20))))
         (concat
          addr
          "                db   $"
          (s-join ",$"
                  (string-chunk bytes 2))

          )))))


  (defun replace-pattern-map (pat fun)
    (interactive)
    (let ((line (thing-at-point 'line t)))
      (when (string-match pat line)
        (end-of-line)
        (newline)
        (insert (funcall fun (substring line 0 -1)))
        (previous-line)
        (delete-line)
        (forward-line 1)
        (replace-pattern-map pat fun)
        )
      )
    )

  (defun bon-bytes ()
    (interactive)
    (replace-pattern-map "[0-9A-F]+:" 'parse-b-line)
    )

  (defun parse-b-line(line)
    (let* ((comms (s-split ";" line))
           (toks (s-split " " (s-trim (car comms))))
           (head (s-chop-right 1 (car toks))))
      (concat head
              "                db   "
              (s-join ","
                      (seq-map (lambda (l) (concat "$" l))
                               (cdr toks)
                               ))
              (if (< 1 (length comms))
                  (concat " ; " (cadr comms))
                ""))))

  (parse-b-line "1234: 12 32 41 23 FF")

  #+END_SRC
  (cdr (s-split ";" "asd ; asdf"))

1234: 23 42 52 12 55 FF ; one two thre
4342: 43 24 43
2341: 32 12 53 33 13  ; foor five siz
dfasd
